<!doctype html><html><head><title>Webassembly 技术的探索与实践</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=author content="Ziv小威"><meta name=Keywords content="Ziv小威,Ziv,Web 前端,Web 开发者"><meta name=email content="wewoor@foxmail.com"><meta name=description content="Webassembly 是一种可以在浏览器端运行二进制格式代码的技术，他的目标则是想提供接近 Native code 的执行效率的技术体验"><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><meta property="og:title" content="Webassembly 技术的探索与实践"><meta property="og:description" content="Webassembly 是一种可以在浏览器端运行二进制格式代码的技术，他的目标则是想提供接近 Native code 的执行效率的技术体验"><meta property="og:type" content="article"><meta property="og:url" content="//imziv.com/posts/2018/webassembly-%E6%8A%80%E6%9C%AF%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/"><meta property="article:published_time" content="2018-01-05T21:54:33+00:00"><meta property="article:modified_time" content="2018-01-05T21:54:33+00:00"><meta property="og:site_name" content="Ziv小威"><meta name=twitter:card content="summary"><meta name=twitter:title content="Webassembly 技术的探索与实践"><meta name=twitter:description content="Webassembly 是一种可以在浏览器端运行二进制格式代码的技术，他的目标则是想提供接近 Native code 的执行效率的技术体验"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-50390715-1','auto');ga('send','pageview');}</script><script src=/vendor/js/jquery.min.js></script><script src=/vendor/js/popper.min.js></script><script src=/vendor/js/bootstrap.min.js></script><script src=/vendor/js/smooth-scroll.polyfills.min.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><script src=/vendor/js/vue.min.js></script><link type=text/css rel=stylesheet href=/vendor/fontawesome/css/all.min.css><link type=text/css rel=stylesheet href=/vendor/fontawesome/css/brands.min.css><link rel=icon href=/images/favicon.png><link rel=stylesheet href=//imziv.com/scss/journal.min.47aa1ffb60880ad8c72feecd6962a14331eca7a7a30e08354a1ca91009b8bc5b.css integrity="sha256-R6of+2CICtjHL+7NaWKhQzHsp6ejDgg1ShypEAm4vFs=" media=screen><link rel=stylesheet href=//imziv.com/scss/dark-mode.min.832f90e2bc07191c85a3b6c0310607f539897546b1126dd04df64aff22316ecd.css integrity="sha256-gy+Q4rwHGRyFo7bAMQYH9TmJdUaxEm3QTfZK/yIxbs0=" media=screen><script src=//imziv.com/js/loadCSS.js></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");</script><script src=//imziv.com/js/toc-collapse.js></script><script src=https://cdn.jsdelivr.net/npm/vue-disqus@3/dist/vue-disqus.js></script></head><body><div id=app><div ref=sideContainer class=side-container><a class="a-block nav-head false" href=//imziv.com><div class=nav-title>让美的事情发生</div><div class=nav-subtitle>Ziv 小威</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/>网志</a>
<a class="a-block nav-link-item false" href=/categories>分类</a>
<a class="a-block nav-link-item false" href=/tags>标签</a>
<a class="a-block nav-link-item active" href=/posts>归档</a>
<a class="a-block nav-link-item false" href=/about>关于</a><div class=nav-link-item><a style=margin-right:8px href=https://github.com/wewoor target=_blank><i title=Github class="fab fa-github"></i></a><a style=margin-right:8px href=//twitter.com/ZivLeft target=_blank><i title=Twitter class="fab fa-twitter"></i></a><a style=margin-right:8px href=//www.instagram.com/wewoor/ target=_blank><i title=Instagram class="fab fa-instagram"></i></a><a style=margin-right:8px href=//slides.com/wewoor target=_blank><i title=Slides class="fab fa-slideshare"></i></a><a style=margin-right:8px href=https://www.zhihu.com/people/zivxiaowei target=_blank><i title=知乎 class="fab fa-zhihu"></i></a><a style=margin-right:8px href=mailto:wewoor@foxmail.com target=_blank><i title="Email to me!" class="fa fa-envelope"></i></a><a href=/index.xml target=_blank><i title=Feed class="fas fa-rss"></i></a></div></div><div class=nav-footer>&copy;
2012-2020 Ziv小威
Built by Hugo <a href=https://github.com/amazingrise/hugo-theme-diary>(Diary)</a></div></div><div ref=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- 目录 -</center><ul><ul class=collapse data-toggle=collapse><ul class=collapse data-toggle=collapse><ul class=collapse data-toggle=collapse><li><a href=#%e7%ae%80%e4%bb%8b onclick="onNavClick(`#简介-nav`)" id=简介-nav>简介</a></li><li><a href=#asmjs-%e4%b8%8e-wasm onclick="onNavClick(`#asmjs-与-wasm-nav`)" id=asmjs-与-wasm-nav>asm.js 与 wasm</a></li><li><a href=#wasm-%e6%96%87%e4%bb%b6%e4%b8%8e-javascript-%e7%94%9f%e6%88%90%e6%9c%ba%e5%99%a8%e7%a0%81%e7%9a%84%e5%8c%ba%e5%88%ab onclick="onNavClick(`#wasm-文件与-javascript-生成机器码的区别-nav`)" id=wasm-文件与-javascript-生成机器码的区别-nav>wasm 文件与 Javascript 生成机器码的区别</a></li><li><a href=#%e7%94%a8-cc-%e7%bc%96%e5%86%99%e4%b8%80%e4%b8%aa-wasm-%e6%a8%a1%e5%9d%97 onclick="onNavClick(`#用-cc-编写一个-wasm-模块-nav`)" id=用-cc-编写一个-wasm-模块-nav>用 C/C++ 编写一个 wasm 模块</a></li><li><a href=#wasm-%e4%b8%8e-javascript-%e6%a8%a1%e5%9d%97%e6%b7%b7%e7%94%a8 onclick="onNavClick(`#wasm-与-javascript-模块混用-nav`)" id=wasm-与-javascript-模块混用-nav>wasm 与 Javascript 模块混用</a></li><li><a href=#%e5%85%b6%e4%bb%96%e7%bc%96%e5%86%99-wasm-%e7%9a%84%e6%96%b9%e6%b3%95 onclick="onNavClick(`#其他编写-wasm-的方法-nav`)" id=其他编写-wasm-的方法-nav>其他编写 wasm 的方法</a></li><li><a href=#%e8%83%bd%e7%94%a8-javascript-%e6%89%93%e5%8c%85%e6%88%90-wasm-%e5%90%97 onclick="onNavClick(`#能用-javascript-打包成-wasm-吗-nav`)" id=能用-javascript-打包成-wasm-吗-nav>能用 Javascript 打包成 wasm 吗</a></li><li><a href=#%e6%80%bb%e7%bb%93 onclick="onNavClick(`#总结-nav`)" id=总结-nav>总结</a></li><li><a href=#%e5%8f%82%e8%80%83 onclick="onNavClick(`#参考-nav`)" id=参考-nav>参考</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a class=pagination-action v-on:click=toggleDarkMode><i class="material-icons pagination-action-icon" v-if=isDarkMode>brightness_4</i>
<i class="material-icons pagination-action-icon" v-else=isDarkMode>brightness_7</i></a></div></div><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/>网志</a>
<a class="a-block drawer-menu-item false" href=/categories>分类</a>
<a class="a-block drawer-menu-item false" href=/tags>标签</a>
<a class="a-block drawer-menu-item active" href=/posts>归档</a>
<a class="a-block drawer-menu-item false" href=/about>关于</a><div class=toc><div class=toc-content><center>- 目录 -</center><ul><ul class=collapse data-toggle=collapse><ul class=collapse data-toggle=collapse><ul class=collapse data-toggle=collapse><li><a href=#%e7%ae%80%e4%bb%8b onclick="onNavClick(`#简介-nav`)" id=简介-nav>简介</a></li><li><a href=#asmjs-%e4%b8%8e-wasm onclick="onNavClick(`#asmjs-与-wasm-nav`)" id=asmjs-与-wasm-nav>asm.js 与 wasm</a></li><li><a href=#wasm-%e6%96%87%e4%bb%b6%e4%b8%8e-javascript-%e7%94%9f%e6%88%90%e6%9c%ba%e5%99%a8%e7%a0%81%e7%9a%84%e5%8c%ba%e5%88%ab onclick="onNavClick(`#wasm-文件与-javascript-生成机器码的区别-nav`)" id=wasm-文件与-javascript-生成机器码的区别-nav>wasm 文件与 Javascript 生成机器码的区别</a></li><li><a href=#%e7%94%a8-cc-%e7%bc%96%e5%86%99%e4%b8%80%e4%b8%aa-wasm-%e6%a8%a1%e5%9d%97 onclick="onNavClick(`#用-cc-编写一个-wasm-模块-nav`)" id=用-cc-编写一个-wasm-模块-nav>用 C/C++ 编写一个 wasm 模块</a></li><li><a href=#wasm-%e4%b8%8e-javascript-%e6%a8%a1%e5%9d%97%e6%b7%b7%e7%94%a8 onclick="onNavClick(`#wasm-与-javascript-模块混用-nav`)" id=wasm-与-javascript-模块混用-nav>wasm 与 Javascript 模块混用</a></li><li><a href=#%e5%85%b6%e4%bb%96%e7%bc%96%e5%86%99-wasm-%e7%9a%84%e6%96%b9%e6%b3%95 onclick="onNavClick(`#其他编写-wasm-的方法-nav`)" id=其他编写-wasm-的方法-nav>其他编写 wasm 的方法</a></li><li><a href=#%e8%83%bd%e7%94%a8-javascript-%e6%89%93%e5%8c%85%e6%88%90-wasm-%e5%90%97 onclick="onNavClick(`#能用-javascript-打包成-wasm-吗-nav`)" id=能用-javascript-打包成-wasm-吗-nav>能用 Javascript 打包成 wasm 吗</a></li><li><a href=#%e6%80%bb%e7%bb%93 onclick="onNavClick(`#总结-nav`)" id=总结-nav>总结</a></li><li><a href=#%e5%8f%82%e8%80%83 onclick="onNavClick(`#参考-nav`)" id=参考-nav>参考</a></li></ul></div></div></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a ref=navTitle class=navbar-brand href=//imziv.com>让美的事情发生</a>
<button type=button class=nav-darkmode-toggle v-on:click=toggleDarkMode>
<i class=material-icons v-if=isDarkMode>brightness_4</i>
<i class=material-icons v-else=isDarkMode>brightness_7</i></button></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=//imziv.com><div class=single-column-header-title>让美的事情发生</div><div class=single-column-header-subtitle>Ziv 小威</div></a></div><div id=content><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>Webassembly 技术的探索与实践<div class=post-subtitle>Webassembly 是一种可以在浏览器端运行二进制格式代码的技术，他的目标则是想提供接近 Native code 的执行效率的技术体验</div><div class=post-meta><time itemprop=datePublished>2018-01-05 21:54</time>
<i class=material-icons>folder</i>
<a href=/categories/>[计算机科学]</a>
&nbsp;
<i class=material-icons>label</i>
<a href=/tags/webassembly>Webassembly</a>
&nbsp;
<a href=/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF>前端技术</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h4 id=简介>简介</h4><p><code>Webassembly</code> 是一种可以在浏览器端运行二进制格式代码的技术，他的目标则是想提供接近<code>Native code</code>的执行效率的技术体验。 相较于文本类型的<code>Javascirpt</code>而言，它拥有更小的体积，更短的加载时间，和更好的执行性能等特点 。<code>Webassembly</code> 允许你使用<code>Rust</code>或者<code>C/C++</code>等静态语言来编写，并生成目标文件后缀为<code>wasm</code>的二进制格式文件。通过<code>Fetch</code>或者<code>Ajax</code>与<code>Webassembly</code>提供的 API ，我们可以实现<code>Javascipt</code>与<code>wasm</code>模块的混用。</p><h4 id=asmjs-与-wasm><code>asm.js</code> 与 <code>wasm</code></h4><p>相信很多人跟我一样有些疑问，<a href=http://asmjs.org/>asm.js</a> 和<code>wasm</code>的关系，<code>asm.js</code>是<code>Mozila</code>工程师<code>ALON ZAKAI</code>提出的一种将静态语言编译为<code>javascript</code>的一种解决方案，这里有官方的<a href=http://kripken.github.io/mloc_emscripten_talk/#/>PPT</a>。而 asm.js 则实际上是 Javascript 的一个子集，通过在已有<code>Javascript</code>语法特上性进行可行的提前优化和性能改进（例如强制类型的一致性、手动的内存管理），从而达到编译器对<code>Javascript</code>代码提前优化的目的。所以，<code>asm.js</code> 实际上是一种针对<code>Javascript</code>编译器进行优化过的<code>Javascript</code>文本代码，而<code>wasm</code>则是浏览器直接支持的一种二进制格式文件，所以在加载速度上，文件体积上，执行效率上有更多优势。编写符合规范的<code>asm.js</code>代码，通过<a href=http://kripken.github.io/emscripten-site/docs/getting_started/Tutorial.html>Emscripten</a>编译工具来将静态语言编译为<code>asm.js</code>目标即可。</p><h5 id=c语言源程序><code>c</code>语言源程序</h5><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00688b;font-weight:700>int</span> <span style=color:#008b45>f</span> (<span style=color:#00688b;font-weight:700>int</span> var) {
    <span style=color:#8b008b;font-weight:700>return</span> var + <span style=color:#b452cd>1</span>;
}
</code></pre></div><h5 id=编译后的asmjs目标文件>编译后的<code>asm.js</code>目标文件</h5><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#228b22>// 通过`|0`提前声明变量和函数的返回类型。
</span><span style=color:#228b22></span><span style=color:#8b008b;font-weight:700>function</span> f(i) {
  i = i|<span style=color:#b452cd>0</span>;
  <span style=color:#8b008b;font-weight:700>return</span> (i + <span style=color:#b452cd>1</span>)|<span style=color:#b452cd>0</span>;
}
</code></pre></div><h5 id=cc-文件编译为-asmjs-目标文件的过程><code>C/C++</code> 文件编译为 <code>asm.js</code> 目标文件的过程</h5><p><img src="https://note.youdao.com/yws/api/personal/file/WEB56a415cc2ee776664734fbf5d912cc76?method=download&shareKey=7757bddfdf2f0225dde6dd34d051aad4" alt=graph0></p><p>注：LLVM 为底层虚拟机（Low Level Virtual Machine）的缩写，一种用 C++编写的, 可以用于优化任何静态语言（例如 Java，Go, Rust, Swift）的底层编译器基础技术。</p><p>具体的编写和编译<code>asm.js</code>的方法可以查看 <a href=http://kripken.github.io/emscripten-site/docs/getting_started/Tutorial.html>Emscripten</a> <a href=http://kripken.github.io/emscripten-site/docs/getting_started/Tutorial.html>官方</a>相关教程。</p><h4 id=wasm-文件与-javascript-生成机器码的区别><code>wasm</code> 文件与 <code>Javascript</code> 生成机器码的区别</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEBa1771260e0b8fcf0c5518d263ab1f41b?method=download&shareKey=a2b56853e9811bc6fd9e2c563056b8f3" alt=graph1></p><p>对比 2 种文件生成机器码的流程会发现，<code>Javascript</code> 文件生成机器码需要经过语法解析，代码优化，最后才转换成机器码等过程，而<code>wasm</code>的优势是本身就是通过编译器并优化过后的二进制文件，可以直接转换为机器码，省去了<code>Javascript</code>需要解析，优化的工作，所以在加载和执行上本身就具有优势。接下来我们尝试用<code>C/C++</code>写一个<code>wasm</code>模块。</p><h4 id=用-cc-编写一个-wasm-模块>用 <code>C/C++</code> 编写一个 <code>wasm</code> 模块</h4><p>搭建和安装 wasm 编写环境的步骤这里就不写了，具体可以查看<a href=http://webassembly.org/getting-started/developers-guide/>官方</a>， 这里我会编写一个模块，然后通过浏览器浏览运行结果。在这里我们利用递归算法，编写一个阶乘计算的模块<code>factorial.c</code>，具体代码如下：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#1e889b>#include</span> <span style=color:#1e889b>&lt;stdio.h&gt;</span><span style=color:#1e889b>
</span><span style=color:#1e889b></span>
<span style=color:#00688b;font-weight:700>long</span> <span style=color:#008b45>factorial</span>(<span style=color:#00688b;font-weight:700>int</span> num) {
    <span style=color:#8b008b;font-weight:700>if</span> (num &lt;= <span style=color:#b452cd>0</span>) <span style=color:#8b008b;font-weight:700>return</span> <span style=color:#b452cd>1</span>;
    <span style=color:#8b008b;font-weight:700>else</span> {
        <span style=color:#8b008b;font-weight:700>return</span> num * factorial(num - <span style=color:#b452cd>1</span>);
    }
}


<span style=color:#00688b;font-weight:700>int</span> <span style=color:#008b45>main</span> () {
    <span style=color:#00688b;font-weight:700>int</span> num = factorial(<span style=color:#b452cd>10</span>);
    printf(<span style=color:#cd5555>&#34;The Result: %d </span><span style=color:#cd5555>\n</span><span style=color:#cd5555>&#34;</span>, num);
}
</code></pre></div><p>执行<code>gcc factorial.c</code>命令，生成<code>a.out</code>文件，执行<code>./a.out</code>，输出<code>The Result: 3628800</code>, 测试成功。</p><h5 id=编译factorialc为-wasm-模块>编译<code>factorial.c</code>为 <code>wasm</code> 模块</h5><p><code>emcc</code>命令本身支持多重级别的优化编译选项<code>（-O0 (no optimization), -O1, -O2, -Os, -Oz, and -O3）</code>，这里我们使用如下命令：</p><blockquote><p>emcc -o test.html factorial.c -o3 -s WASM=1</p></blockquote><ul><li>通过<code>-o test.html</code>指定<code>Emscripten</code>生成运行<code>wasm</code>模块的<code>html</code>文件</li><li><code>-o3</code>指定优化选项，适合发布构建</li><li><code>-s WASM=1</code> 指定<code>Emscripten</code>输出格式为<code>wasm</code>，默认打包为<code>asm.js</code>文件</li></ul><p>执行后会生成如下文件：</p><ul><li><code>test.html</code> 编译并实例化 test.wasm 模块，并在浏览器展示</li><li><code>test.js</code> 是<code>C</code>语言模块与<code>Javascript/wasm</code>文件(test.wasm)之间进行转换通信的中间代码</li><li><code>test.wasm</code> 二进制的<code>wasm</code>模块代码</li></ul><p>在浏览器中打开<code>test.html</code>文件，即能看到展示结果:</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf4563187ab32775feb89be9452a528a3?method=download&shareKey=732779258eb8696087a27aa992cee187" alt=display_wasm></p><p>可以看到是一个比较粗糙的展示界面。</p><h4 id=wasm-与-javascript-模块混用><code>wasm</code> 与 <code>Javascript</code> 模块混用</h4><p>在上面的示例中，我们编写了一个<code>C</code>模块，接下来我们希望在 JS 中调用<code>factorial</code>方法，想要在浏览器客户端使用<code>wasm</code>模块，与 JS 模块一样，我们需要先加载，再执行。</p><h5 id=加载-wasm-模块>加载 <code>wasm</code> 模块</h5><p>由于<code>WebAssembly</code>暂时并不能支持类似于通过<code>&lt;script type="module"></code>或者 ES6 <code>import</code>来声明引入，所以目前的方式是利用 Fetch 或者 Ajax 的方法来加载，结合<code>WebAssembly.instantiate()</code>API 来实例化加载过来的<code>wasm</code>二进制代码来实现的。示例如下：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#228b22>// Fetch
</span><span style=color:#228b22></span>fetch(<span style=color:#cd5555>&#39;simple.wasm&#39;</span>).then(response =&gt;
  response.arrayBuffer()
).then(bytes =&gt;
  WebAssembly.instantiate(bytes, importObject)
).then(results =&gt; {
  <span style=color:#228b22>// Do something
</span><span style=color:#228b22></span>});

<span style=color:#228b22>// Ajax
</span><span style=color:#228b22></span>request = <span style=color:#8b008b;font-weight:700>new</span> XMLHttpRequest();
request.open(<span style=color:#cd5555>&#39;GET&#39;</span>, <span style=color:#cd5555>&#39;simple.wasm&#39;</span>);
request.responseType = <span style=color:#cd5555>&#39;arraybuffer&#39;</span>;
request.send();

request.onload = <span style=color:#8b008b;font-weight:700>function</span>() {
  <span style=color:#8b008b;font-weight:700>var</span> bytes = request.response;
  WebAssembly.instantiate(bytes, importObject).then(results =&gt; {
     <span style=color:#228b22>// Do something
</span><span style=color:#228b22></span>  });
};
</code></pre></div><h5 id=调用-cc-中的方法>调用 <code>C/C++</code> 中的方法</h5><p>以上只是通过 Fetch API 获取 wasm 文件的方法，想要在 JS 中调用 C 文件里面的方法，我们需要重新打包下<code>factorial.c</code>源文件</p><blockquote><p>emcc factorial.c -o3 -s WASM=1 -s ONLY_MY_CODE=1 -s EXPORTED_FUNCTIONS=&rdquo;['_factorial&rsquo;]&rdquo; -o factorial.js</p></blockquote><ul><li>-s ONLY_MY_CODE=1 仅仅打包源文件的代码，阻止包含部分 Emscripten 的标准库</li><li>-s EXPORTED_FUNCTIONS=&rdquo;['_factorial&rsquo;]&rdquo; 指定导出方法（注意：这里的方法名称不加下划线会报错）</li></ul><p>与上面的打包示例一样， 执行完命令会生成对应的<code>factorial.wasm</code>和<code>factorial.js</code>文件，这里我们只需要 wasm 文件即可。JS 端完整的调用代码：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#228b22>// 内存管理
</span><span style=color:#228b22></span><span style=color:#8b008b;font-weight:700>const</span> memory = <span style=color:#8b008b;font-weight:700>new</span> WebAssembly.Memory({ initial: <span style=color:#b452cd>256</span>, maximum: <span style=color:#b452cd>256</span> });
<span style=color:#228b22>// WebAssembly实例对象的环境配置
</span><span style=color:#228b22></span><span style=color:#8b008b;font-weight:700>const</span> importObj = {
    <span style=color:#cd5555>&#39;global&#39;</span>: {},
    env: {
        abortStackOverflow: () =&gt; { <span style=color:#8b008b;font-weight:700>throw</span> <span style=color:#8b008b;font-weight:700>new</span> <span style=color:#658b00>Error</span>(<span style=color:#cd5555>&#39;overflow&#39;</span>); },
        table: <span style=color:#8b008b;font-weight:700>new</span> WebAssembly.Table({ initial: <span style=color:#b452cd>0</span>, maximum: <span style=color:#b452cd>0</span>, element: <span style=color:#cd5555>&#39;anyfunc&#39;</span> }),
        tableBase: <span style=color:#b452cd>0</span>,
        memory: memory,
        memoryBase: <span style=color:#b452cd>1024</span>,
        STACKTOP: <span style=color:#b452cd>0</span>,
        STACK_MAX: memory.buffer.byteLength,
    }
};

<span style=color:#8b008b;font-weight:700>var</span> CModule;

fetch(<span style=color:#cd5555>&#39;factorial.wasm&#39;</span>, { credentials: <span style=color:#cd5555>&#39;same-origin&#39;</span> }).then(res =&gt; {
    <span style=color:#8b008b;font-weight:700>return</span> res.arrayBuffer()
}).then(bytes =&gt; {
    console.log(<span style=color:#cd5555>&#39;bytes:&#39;</span>, bytes)
    <span style=color:#228b22>// 利用WebAssembly.instantiate接口将wasm模块的方法与importObject进行映射
</span><span style=color:#228b22></span>    <span style=color:#8b008b;font-weight:700>return</span> WebAssembly.instantiate(bytes, importObj)
}).then(obj =&gt; {
    console.log(<span style=color:#cd5555>&#39;obj:&#39;</span>, obj)
    <span style=color:#228b22>// 执行调用factorial
</span><span style=color:#228b22></span>    CModule = obj.instance.exports;
})

<span style=color:#8b008b;font-weight:700>function</span> factorial() {
    <span style=color:#8b008b;font-weight:700>var</span> num = <span style=color:#658b00>document</span>.getElementById(<span style=color:#cd5555>&#39;Input&#39;</span>).value;
    <span style=color:#8b008b;font-weight:700>var</span> val = CModule._factorial(num)
    <span style=color:#658b00>document</span>.getElementById(<span style=color:#cd5555>&#39;Dispaly&#39;</span>).innerHTML = <span style=color:#cd5555>`结果：</span><span style=color:#cd5555>${</span>val<span style=color:#cd5555>}</span><span style=color:#cd5555>`</span>;
}
</code></pre></div><p>html 部分代码：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#8b008b;font-weight:700>div</span> <span style=color:#658b00>style</span>=<span style=color:#cd5555>&#34;width: 200px; margin: auto; margin-top: 20px;&#34;</span>&gt;
    &lt;<span style=color:#8b008b;font-weight:700>h2</span>&gt;阶乘计算&lt;/<span style=color:#8b008b;font-weight:700>h2</span>&gt;
    &lt;<span style=color:#8b008b;font-weight:700>input</span> <span style=color:#658b00>type</span>=<span style=color:#cd5555>&#34;number&#34;</span> <span style=color:#658b00>id</span>=<span style=color:#cd5555>&#34;Input&#34;</span>/&gt;
    &lt;<span style=color:#8b008b;font-weight:700>p</span> <span style=color:#658b00>id</span>=<span style=color:#cd5555>&#34;Dispaly&#34;</span>&gt;&lt;/<span style=color:#8b008b;font-weight:700>p</span>&gt;
    &lt;<span style=color:#8b008b;font-weight:700>button</span> <span style=color:#658b00>onclick</span>=<span style=color:#cd5555>&#34;factorial()&#34;</span>&gt;计算&lt;/<span style=color:#8b008b;font-weight:700>button</span>&gt;
&lt;/<span style=color:#8b008b;font-weight:700>div</span>&gt;
</code></pre></div><h5 id=以上完整的代码示例请看httpsgithubcomwewoorwasm-labtreemasterexample-1>以上完整的代码示例：<a href=https://github.com/wewoor/wasm-lab/tree/master/example-1>请看</a></h5><h4 id=其他编写-wasm-的方法>其他编写 <code>wasm</code> 的方法</h4><p>如果你实在不想用 C/C++来编写的话，实际上目前有多种编写 wasm 的方案，可以配合 Webpack 一起使用。目前我收集了一些方式：</p><ul><li><a href=https://github.com/DenisKolodin/yew>Rust</a>（Yew）
Yew is a modern Rust framework inspired by Elm and ReactJS.</li><li><a href=https://github.com/AssemblyScript/prototype>AssemblyScript - Typescript</a></li><li><a href=https://github.com/ballercat/walt>Walt - JavaScript-like syntax</a></li></ul><p>其中<a href=https://github.com/DenisKolodin/yew>Yew</a>支持在 Rust 代码中直接编写 HTML 标签，官方示例的代码是这样的：</p><div class=highlight><pre style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>html! {
    &lt;<span style=color:#8b008b;font-weight:700>section</span> <span style=color:#658b00>class</span>=<span style=color:#cd5555>&#34;todoapp&#34;</span><span style=color:#a61717;background-color:#e3d2d2>,</span>&gt;
        &lt;<span style=color:#8b008b;font-weight:700>header</span> <span style=color:#658b00>class</span>=<span style=color:#cd5555>&#34;header&#34;</span><span style=color:#a61717;background-color:#e3d2d2>,</span>&gt;
            &lt;<span style=color:#8b008b;font-weight:700>h1</span>&gt;{ &#34;todos&#34; }&lt;/<span style=color:#8b008b;font-weight:700>h1</span>&gt;
            { view_input(<span style=color:#a61717;background-color:#e3d2d2>&amp;</span>model) }
        &lt;/<span style=color:#8b008b;font-weight:700>header</span>&gt;
        &lt;<span style=color:#8b008b;font-weight:700>section</span> <span style=color:#658b00>class</span>=<span style=color:#cd5555>&#34;main&#34;</span><span style=color:#a61717;background-color:#e3d2d2>,</span>&gt;
            &lt;<span style=color:#8b008b;font-weight:700>input</span> <span style=color:#658b00>class</span>=<span style=color:#cd5555>&#34;toggle-all&#34;</span><span style=color:#a61717;background-color:#e3d2d2>,</span>
                   <span style=color:#658b00>type</span>=<span style=color:#cd5555>&#34;checkbox&#34;</span><span style=color:#a61717;background-color:#e3d2d2>,</span>
                   <span style=color:#658b00>checked</span>=<span style=color:#cd5555>model.is_all_completed(),</span>
                   <span style=color:#658b00>onclick</span>=<span style=color:#cd5555>|_|</span> <span style=color:#658b00>Msg::ToggleAll</span><span style=color:#a61717;background-color:#e3d2d2>,</span> /&gt;
            { view_entries(<span style=color:#a61717;background-color:#e3d2d2>&amp;</span>model) }
        &lt;/<span style=color:#8b008b;font-weight:700>section</span>&gt;
    &lt;/<span style=color:#8b008b;font-weight:700>section</span>&gt;
}
</code></pre></div><p>更多的用法可以去<code>Yew</code>项目<a href=https://github.com/DenisKolodin/yew>首页</a>看看。</p><h4 id=能用-javascript-打包成-wasm-吗>能用 Javascript 打包成 wasm 吗</h4><p>相信很多人看到这里会问，作为一个主要开发语言是 Javascript 的开发者，当然希望通过一种语言就能完成开发工作，而且
既然 Javascript 代码最后转换为机器码，中间有那么多步骤，现在开发大部分都是用 Webpack 打包，何不写个编译器，直接把 JS 打包编译成 wasm 不就好了？</p><p>理论上当然是可以的，所以才有上面列举的类 JS 语法的编译器<a href=https://github.com/ballercat/walt>Walt - JavaScript-like syntax</a>, 但是如果说想要完全使用 wasm 替代现有的 Javascript，目前来讲不现实，也没什么意义。首先 wasm 的设计目标并非是取代 Javascript，在刚才我们实现 C/C++ 的例子中我们可以体会到，整个使用过程的成本是相当之高的。Javascript 本身是动态脚本语言，在我们使用 Webpack + Babel 编译 JS 之前，简单的 Web 使用 JS 开发交互是十分简单的，不需要所谓的全家桶(Webpack + ReactJS + Redux)， 只需要一个 jQuery , 或者原生 JS 就可以轻松完成，这无疑对开发者而言是成本更小的选择，并且像需要大量交互操作 HTML DOM 的这种事情，显然 JS 会更顺手一些。而正如我们在上面的介绍中介绍 asm.js 一样，wasm 提前编译和优化代码，并直接生成更小的二进制文件，实则在追寻更极致的性能，而这些性能好像更多是那些需要大量计算的游戏，和复杂的 Web 应用而需要的。所以实际上二者更多的是在形成一种互补关系。</p><p>另外，我们可以看看官方针对这个问题的 Issue <a href=https://github.com/WebAssembly/design/issues/219>Will there be a JS -> WASM compiler</a>。</p><h4 id=总结>总结</h4><p>2017 年 3 月份，WebAssembly 社区小组成员的四大代表（ Chrome, Edge, Firefox, and WebKit）对 WebAssembly API 已经达成基本的共识，表示未来的主流浏览器默认都会支持 wasm 。需要搞清楚的是 wasm 技术并非是为了替代现有 Javascript 而出现的一种技术，而是为了填补 JS 本身的一些不足。例如需要大量 GPU, CPU 计算的游戏或者算法，但是对于需要大量 DOM 交互，常规的 Web 应用而言，Javascript 仍然是不不可替代的。</p><h4 id=参考>参考</h4><ul><li><a href=https://developer.mozilla.org/zh-CN/docs/WebAssembly>MDN</a></li><li><a href=https://zh.wikipedia.org/wiki/Asm.js>Wikipedia asm.js</a></li><li><a href="https://codelabs.developers.google.com/codelabs/web-assembly-intro/index.html?index=..%2F..%2Findex#0">Web-assembly-intro</a></li><li><a href=https://blog.sessionstack.com/how-javascript-works-a-comparison-with-webassembly-why-in-certain-cases-its-better-to-use-it-d80945172d79>How JavaScript works: A comparison with WebAssembly + why in certain cases it’s better to use it over JavaScript</a></li><li><a href=https://github.com/WebAssembly/binaryen/issues/670>WasmModule Instantiate</a></li></ul><hr width=100% id=EOF><p style=color:#777>最后修改于 2018-01-05</p></div></div><nav class=post-pagination><a class=newer-posts href=//imziv.com/posts/2018/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-console/>下回<br>你不知道的 Console</a>
<a class=older-posts href=//imziv.com/posts/2018/2017%E5%B9%B4%E5%B0%8F%E7%BB%93/>上回<br>2017 年小结</a></nav><div class=post-comment-wrapper><div class=comments><vue-disqus shortname=imziv></vue-disqus></div><noscript><noscript>请开启 JavaScript 以便使用评论服务。</noscript></noscript><a href=https://disqus.com/ class=dsq-brlink>Comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div></div><div id=single-column-footer>&copy;
2012-2020 Ziv小威
Built by Hugo <a href=https://github.com/amazingrise/hugo-theme-diary>(Diary)</a></div></div><script>let app;app=new Vue({el:'#app',data:{scrollY:0,navOpacity:0,isDrawerOpen:false,mounted:false,isDarkMode:false},methods:{sgn(t,x){let k=1./(1.-2*t);if(x<=t)return 0;else if(x>=1-t)return 1;else{return k*(x-t);}},handleScroll(){this.scrollY=window.scrollY;this.navOpacity=this.sgn(.0,Math.min(1,Math.max(0,window.scrollY/(this.pageHeadHeight()-this.navBarHeight()*0.8))));const{navBar,navBackground,navTitle,extraContainer,streamContainer}=this.$refs;if(this.navOpacity>=1){navBackground.style.opacity=1;navTitle.style.opacity=1;}else{navBackground.style.opacity=0;navTitle.style.opacity=0;}},handleResize(){const{navBar,navBackground,navTitle,extraContainer,streamContainer}=this.$refs;extraContainer.style.left=(streamContainer.offsetWidth-extraContainer.offsetWidth)+'px';},navBarHeight(){return this.$refs.navBar.offsetHeight;},pageHeadHeight(){return this.$refs.pageHead.offsetHeight;},toggleDrawer(){this.isDrawerOpen=!this.isDrawerOpen;document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset';},closeDrawer(){this.isDrawerOpen=false;document.getElementsByTagName('html')[0].style.overflow=this.isDrawerOpen?'hidden':'unset';},toggleDarkMode(){this.isDarkMode=!this.isDarkMode;if(this.isDarkMode==true){document.cookie="night=1;path=/";document.body.classList.add("night");}else{document.cookie="night=0;path=/";document.body.classList.remove("night");}}},created(){window.addEventListener('scroll',this.handleScroll);window.addEventListener('resize',this.handleResize);window._nonDesktop=function(){let check=false;(function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check=true;})(navigator.userAgent||navigator.vendor||window.opera);return check;};var night=document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/,"$1");if(night==""){if(window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches){}}else{if(night=="1"){this.toggleDarkMode();}}},mounted(){this.handleScroll();this.handleResize();this.mounted=true;},destroyed(){window.removeEventListener('scroll',this.handleScroll);window.removeEventListener('resize',this.handleResize);}});</script><script src=//imziv.com/js/journal.js></script></body></html>