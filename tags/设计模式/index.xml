<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on 让美的事情发生</title><link>//imziv.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on 让美的事情发生</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2012-2020 Ziv小威</copyright><lastBuildDate>Fri, 23 Nov 2018 17:24:48 +0000</lastBuildDate><atom:link href="//imziv.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>【译】理解 Javascript 中常用的一些设计模式</title><link>//imziv.com/posts/2018/%E8%AF%91%E7%90%86%E8%A7%A3-javascript-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 23 Nov 2018 17:24:48 +0000</pubDate><guid>//imziv.com/posts/2018/%E8%AF%91%E7%90%86%E8%A7%A3-javascript-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>原文地址: Understanding Design Patterns in JavaScript
当我们开始一个新的项目的时候，通常不会立刻开始实际编码的工作，而是首先会理清楚项目的一些需求、问题和目标。在我们可以开始编写代码后， 或者如果你正在处理的是一个更复杂的项目的话，那么我们应该考虑去选择一种最适合项目的设计模式去帮助我们完成工作。
如何理解设计模式 在软件工程中，设计模式是一种用来解决软件设计中一些共通问题的解决方案。设计模式往往是开发工程师最佳实践后的经验总结。通常我们可以把一个设计模式理解为是一个编程模板。
为什么我们需要设计模式 大部分的开发者通常认为设计模式是在浪费时间，或者说他们也并不太知如何适当的去使用这些设计模式。但是适当的使用设计模式的确可以帮助我们编写出更好健壮的代码。
更重要的是，设计模式往往为我们提供了一些沟通上的便利，它可以及时的向正在学习你代码的人展示出你代码意图。例如，如果你在项目中使用了装饰者模式的话，那么一个新的开发者可能马上就知道了你的代码是在干什么，他们可以更多的去关注业务本身，而无需花费过度的精力去理解你的代码。
好了，接让我们看看我们在 Javascript 中常用的一些设计模式吧。
模块模式（Module Pattern） 模块是指一个包含自身完整逻辑代码的代码块，当我们去更新模块中的代码时而不用影响其他代码的部分。模块可以让我们轻易的规避命名空间的污染问题，例如模块拥有自己独立的变量作用域，我们也可以在其他项目中复用我们的模块。
模块是现代 Javascript 应用开发里的不可或缺的部分，它帮助我们轻易的组织和维护代码。在 Javascript 中模块化的方式有很多，通常我们把这些模块化的方法称之为模块化模式。像 Bit 这个工具，它不需要任何重构工作，就可以把我们的模块或者组件转换成其他任何项目中可以复用的代码了。
Javascript 并没有像其他编程语言拥有访问修饰符的特性（现在 Typescript 之类的语言包含这些特性），例如你无法声明变量为私有（private）或者公开（public)。所以模块化模式也常常被用来去模拟封装（Encapsulation) 的理念。
这种模式我们可以通过即行函数 IIFE（immediately-invoked function expression)、闭包和函数作用域来模拟，例如：
const myModule = (function() { const privateVariable = &amp;#39;Hello World&amp;#39;; function privateMethod() { console.log(privateVariable); } return { publicMethod: function() { privateMethod(); } } })(); myModule.publicMethod(); 上面的代码是即行函数的方法，通过立即执行函数，并把返回结果指向了 myModule 变量。由于闭包、返回的对象仍然可以访问定义在即行函数内的函数和变量，当然这些操作是在执行完即行函数产生实例之后了。我们可以看到，变量和方法被定义在即行函数内部，对于模块外部的作用域来说即达到了 private 的效果。
当代码被执行后，变量 myModule 类似于：</description></item><item><title>Decorator 简介及实战</title><link>//imziv.com/posts/2017/decorator-%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%9E%E6%88%98/</link><pubDate>Sun, 05 Nov 2017 14:36:35 +0000</pubDate><guid>//imziv.com/posts/2017/decorator-%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%9E%E6%88%98/</guid><description>前言 用过 Java 的朋友都知道，装饰器（Decorator)是一种十分非常方便改变类运行是行为的一种方式，例如在 Spring 框架中我们用到比较多的注解（@Autowired), 通过它可以自动实例化对象，从而可以精简代码。装饰器是典型的 AOP(Aspect-Oriented-Programming) 编程的应用，类似的 CSS 对于 HTML 的样式也是类似于这种思想，即从切面来改变和影响主对象的行为。
Decorator 简介 Decorator 是一种通过注解表达式就可以扩展类或者方法的函数。Decorator 可以应用到任何一个 class 或者 property 上。列如:
@myDecorator class A {} // 作用class @myDecorator doSomething() {} // 作用表达式 Javascript Decorator 目前任然是 ES7 提案状态，更多该特性的进度可以访问proposal-decorators查看。
Decorator 原理 说到更改对象的属性或者方法，大家肯定会想到Object.defineProperty(obj, prop, descriptor)方法，通过该方法，我们可以轻易的修改或者重写对象的行为或者属性，之前 Vue 中提到的双向绑定，即是通过重写set和get方法来实现的。所以在我们还未正式用上 Decorator 前，都是通过 Object.defineProperty 方法来实现。先来简单的认识下这个方法：
/** * obj : 需要修改属性的对象 * prop : 需要修改对象的属性名称 * descriptor: 用来定义属性具体行为的描述对象 **/ Object.defineProperty(obj, prop, descriptor) descriptor 属性说明 configurable : 定义属性对象是否可以被配置，即如果为 false ，定义修改的描述操作（writeable, get 等等）都无效</description></item></channel></rss>