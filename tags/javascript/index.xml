<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javascript on 让美的事情发生</title><link>//imziv.com/tags/javascript/</link><description>Recent content in Javascript on 让美的事情发生</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2012-2020 Ziv小威</copyright><lastBuildDate>Fri, 23 Nov 2018 17:24:48 +0000</lastBuildDate><atom:link href="//imziv.com/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>【译】理解 Javascript 中常用的一些设计模式</title><link>//imziv.com/posts/2018/%E8%AF%91%E7%90%86%E8%A7%A3-javascript-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 23 Nov 2018 17:24:48 +0000</pubDate><guid>//imziv.com/posts/2018/%E8%AF%91%E7%90%86%E8%A7%A3-javascript-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>原文地址: Understanding Design Patterns in JavaScript
当我们开始一个新的项目的时候，通常不会立刻开始实际编码的工作，而是首先会理清楚项目的一些需求、问题和目标。在我们可以开始编写代码后， 或者如果你正在处理的是一个更复杂的项目的话，那么我们应该考虑去选择一种最适合项目的设计模式去帮助我们完成工作。
如何理解设计模式 在软件工程中，设计模式是一种用来解决软件设计中一些共通问题的解决方案。设计模式往往是开发工程师最佳实践后的经验总结。通常我们可以把一个设计模式理解为是一个编程模板。
为什么我们需要设计模式 大部分的开发者通常认为设计模式是在浪费时间，或者说他们也并不太知如何适当的去使用这些设计模式。但是适当的使用设计模式的确可以帮助我们编写出更好健壮的代码。
更重要的是，设计模式往往为我们提供了一些沟通上的便利，它可以及时的向正在学习你代码的人展示出你代码意图。例如，如果你在项目中使用了装饰者模式的话，那么一个新的开发者可能马上就知道了你的代码是在干什么，他们可以更多的去关注业务本身，而无需花费过度的精力去理解你的代码。
好了，接让我们看看我们在 Javascript 中常用的一些设计模式吧。
模块模式（Module Pattern） 模块是指一个包含自身完整逻辑代码的代码块，当我们去更新模块中的代码时而不用影响其他代码的部分。模块可以让我们轻易的规避命名空间的污染问题，例如模块拥有自己独立的变量作用域，我们也可以在其他项目中复用我们的模块。
模块是现代 Javascript 应用开发里的不可或缺的部分，它帮助我们轻易的组织和维护代码。在 Javascript 中模块化的方式有很多，通常我们把这些模块化的方法称之为模块化模式。像 Bit 这个工具，它不需要任何重构工作，就可以把我们的模块或者组件转换成其他任何项目中可以复用的代码了。
Javascript 并没有像其他编程语言拥有访问修饰符的特性（现在 Typescript 之类的语言包含这些特性），例如你无法声明变量为私有（private）或者公开（public)。所以模块化模式也常常被用来去模拟封装（Encapsulation) 的理念。
这种模式我们可以通过即行函数 IIFE（immediately-invoked function expression)、闭包和函数作用域来模拟，例如：
const myModule = (function() { const privateVariable = &amp;#39;Hello World&amp;#39;; function privateMethod() { console.log(privateVariable); } return { publicMethod: function() { privateMethod(); } } })(); myModule.publicMethod(); 上面的代码是即行函数的方法，通过立即执行函数，并把返回结果指向了 myModule 变量。由于闭包、返回的对象仍然可以访问定义在即行函数内的函数和变量，当然这些操作是在执行完即行函数产生实例之后了。我们可以看到，变量和方法被定义在即行函数内部，对于模块外部的作用域来说即达到了 private 的效果。
当代码被执行后，变量 myModule 类似于：</description></item><item><title>你不知道的 Console</title><link>//imziv.com/posts/2018/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-console/</link><pubDate>Sat, 07 Jul 2018 16:16:51 +0000</pubDate><guid>//imziv.com/posts/2018/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-console/</guid><description>相信很多 Web 开发者跟我一样有个习惯，经常会不自觉的打开感兴趣网站的控制台（Console)。很多公司会在控制台中打印一些招聘或者安全警告的信息。作为一位开发者，当然更多的关心的是这些效果是如何实现的。今天我们不妨来重写认识下 Console 这个 API 对象。
简介 Javascript console是被提供用来访问浏览器Debug控制台的一个全局对象，一般我们可以直接通过console或者 window.console 的方式访问该对象。通常我们会利用该对象 debug 调试，当然你也可以跟其他公司一样，在上面发招聘信息。
其实除去我们平时常用的console.log、console.error、console.warn、console.info 方法外，其实console还有很多非常有用的 API。 当然，事先已经知道的同学当我没说。先看下列这张表：
方法 用途 console.assert() 判断第一个参数是否为真，false 的话抛出异常并且在控制台输出相应信息。 console.clear() 清空控制台 console.count() 以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。 console.debug() console.log 方法的别称，使用方法可以参考 console.log() console.dir() 打印一条以三角形符号开头的语句，可以点击三角展开查看对象的属性。 console.dirxml() 如果可以，打印 XML/HTML 元素表示的指定对象，或者 JavaScript 对象视图。 console.error() 打印一条错误信息，使用方法可以参考string substitution。 console.group() 打印树状结构，配合 groupcollapsed 以及 groupEnd 方法; console.</description></item><item><title>HTML5 文件异步上传 — h5uploader.js</title><link>//imziv.com/posts/2015/html5-%E6%96%87%E4%BB%B6%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0-h5uploader.js/</link><pubDate>Thu, 07 May 2015 23:11:53 +0000</pubDate><guid>//imziv.com/posts/2015/html5-%E6%96%87%E4%BB%B6%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0-h5uploader.js/</guid><description>之前写过一篇 H5 异步文件上传的文章, 但是很多朋友看着我的这个教程还是出现很多问题，文章写的不是很好，比较早了。其实通过 H5 做异步上传已经非常简单了，通过查看文档，便可以很轻松的完成这个功能，当然，如果你不愿意查看文档自己动手的话，那么就用插件咯。h5uploader是我最近封装的 HTML5 上传插件，代码才白来行，使用的话也比较简单，支持文件大小，类型，progress 等等功能。本篇教程，将向你展示 Nodejs,Java 两种服务端的上传方法，并且附有源代码示例。
插件下载 如果你是bower的用户的话，可以直接通过以下命令：
bower install h5uploader --save 当然也可以直接从 Github Clone 此项目：
git clone https://github.com/wewoor/h5uploader.git HTML 代码 &amp;lt;input type=&amp;#34;file&amp;#34; id=&amp;#34;myfile&amp;#34; value=&amp;#34;&amp;#34; name=&amp;#34;myfile&amp;#34; multiple=&amp;#34;multiple&amp;#34;/&amp;gt; &amp;lt;button id=&amp;#34;uploader&amp;#34;&amp;gt;Upload&amp;lt;/button&amp;gt; 以上是一个 file 类型的 input 元素以及一个上传触发按钮，后面带有 multiple 属性，表示次处支持文件多选上传，当然，你也可以一次提交多个 input 元素，例如：
&amp;lt;input type=&amp;#34;file&amp;#34; id=&amp;#34;myfile&amp;#34; value=&amp;#34;&amp;#34; name=&amp;#34;myfile&amp;#34; multiple=&amp;#34;multiple&amp;#34;/&amp;gt; &amp;lt;input type=&amp;#34;file1&amp;#34; id=&amp;#34;myfile1&amp;#34; value=&amp;#34;&amp;#34; name=&amp;#34;myfile&amp;#34; multiple=&amp;#34;multiple&amp;#34;/&amp;gt; &amp;lt;button id=&amp;#34;uploader&amp;#34;&amp;gt;Upload&amp;lt;/button&amp;gt; 这种方法同样是可以的，只不过服务端解析的时候要更麻烦。
Javascript &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;html5uploader.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; var uploader = document.getElementById(&amp;#39;uploader&amp;#39;); uploader.addEventListener(&amp;#34;click&amp;#34;, function(e) { H5Uploader.</description></item><item><title>随笔-家</title><link>//imziv.com/posts/2015/html5-%E5%85%A8%E5%B1%8F%E7%89%B9%E6%80%A7/</link><pubDate>Sat, 24 Jan 2015 21:56:59 +0000</pubDate><guid>//imziv.com/posts/2015/html5-%E5%85%A8%E5%B1%8F%E7%89%B9%E6%80%A7/</guid><description>全屏功能是浏览器很早就支持的一项功能了，可以让你页面中的 video, image ,div 等等子元素实现全屏浏览，从而带来更好的视觉体验，来看看怎么使用吧。先来看看有哪些 API 和事件支持。
API // 元素请求全屏显示 element.requestFullscreen() // 检测文档的当前状态是否允许执行全屏操作 document.fullscreenEnabled() //当前显示的元素是否处于全屏状态，如果处于，则返回为非空对象，否则返回null document.fullscreenElement() //元素退出全屏显示 document.exitFullscreen() 上面除了RequestFullscreen()是支持element 对象以外，其他 3 个都只是支持document.
Event fullscreenchange // 全屏状态更改时触发 fullscreenerror // 执行全屏错误时触发 由于每个浏览器实现的方式不一样，所以我们实际的调用中还不能直接这样写，需要针对不同的浏览器做支持检测，下面跟着详细的例子看下具体兼容代码。
html &amp;lt;body&amp;gt; &amp;lt;img id=&amp;#34;imgFS&amp;#34; src=&amp;#34;&amp;#34;/&amp;gt; &amp;lt;a id=&amp;#34;btnFS&amp;#34; href=&amp;#34;javascript:;&amp;#34;&amp;gt; FullScreen &amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; javascript var fullScreen = document.getElementById(&amp;#39;btnFS&amp;#39;); fullScreen.addEventListener(&amp;#34;click&amp;#34;, function(){ var status = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullscreenEnabled || document.msFullscrrenEnabled; if (status) { var img = document.getElementById(&amp;#34;imgFS&amp;#34;); if (img.requestFullscreen) { img.requestFullscreen(); } else if (img.</description></item></channel></rss>