<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Node.js on 让美的事情发生</title><link>//imziv.com/tags/node.js/</link><description>Recent content in Node.js on 让美的事情发生</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2012-2020 Ziv小威</copyright><lastBuildDate>Tue, 28 Feb 2017 17:35:09 +0000</lastBuildDate><atom:link href="//imziv.com/tags/node.js/index.xml" rel="self" type="application/rss+xml"/><item><title>我用 Express.js 封装了一个服务器容器小工具</title><link>//imziv.com/posts/2017/%E6%88%91%E7%94%A8express.js%E5%B0%81%E8%A3%85%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/</link><pubDate>Tue, 28 Feb 2017 17:35:09 +0000</pubDate><guid>//imziv.com/posts/2017/%E6%88%91%E7%94%A8express.js%E5%B0%81%E8%A3%85%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid><description>背景 我们都知道利用 Node.js 可以非常轻易的就编写一个 Web Server。在没有利用集成 Gulp, Webpack，Web Server 等等脚手架工具前，在做一些简单的 Web 应用的时候，我通常的做法是：用 Express.js 封装好一个 Server.js 文件集成到项目中去，以便于开发和测试。例如通过二维码扫描 Chrome 的开发程序到手机端测试，例如需要跨域调用远程服务器 API, 例如 Ajax 异步加载，等等。当然，偶尔也会用用 Nginx 做测试开发环境，但是 Nginx 这玩意还是感觉太重，并且项目组的有些同学觉得安装麻烦，配置复杂，不易上手。
由于我们经常会收到一些活动页面，或者很少页面的开发需求，移动端，PC 端都有，所以如果每次都大张旗鼓的上脚手架，全家桶实在上有点杀鸡用牛刀的感觉。一堆依赖，每次重复的安装，很占用硬盘空间。正因如此，我便希望把现有的基于 Express.js 的 server 给封装成全局的程序，每次在这些小项目需要的时候，直接一个简单的命令行就可以进行开发和测试，要安装简单，轻便，配置简单。于是这个叫cup的工具就诞生了。
特点 随时随地针对项目目录开启 Server 服务 全局安装，简单的 CLI 支持自定义服务器端口 支持远程服务器代理（Proxy) 基本使用 安装 npm install -g mini-cup 示例 | - test | - css | - styles | - index.html 例如当你有个项目简单到只有以上一些文件和文件夹时，需要添加 server 容器来调试开发，你只需要在控制台切换到test项目所在目录，运行：
cup run test cup默认开启的服务器端口是3000，如果端口占用，或者需要指定其他端口的情况下，则可以通过如下命令：
cup run test -p 8080 通过选项参数-p指定端口为8080</description></item><item><title>NodeJS CSV 导出文件名和内容乱码解决</title><link>//imziv.com/posts/2014/nodejs-csv%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E5%86%85%E5%AE%B9%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/</link><pubDate>Tue, 04 Nov 2014 15:29:19 +0000</pubDate><guid>//imziv.com/posts/2014/nodejs-csv%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E5%86%85%E5%AE%B9%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/</guid><description>// 解决不同浏览器下载文件名称乱码 var userAgent = (req.headers[&amp;#39;user-agent&amp;#39;]||&amp;#39;&amp;#39;).toLowerCase(); res.set(&amp;#39;Content-Type&amp;#39;, &amp;#39;application/octet-stream;charset=utf-8&amp;#39;); if(userAgent.indexOf(&amp;#39;msie&amp;#39;) &amp;gt;= 0 || userAgent.indexOf(&amp;#39;chrome&amp;#39;) &amp;gt;= 0) { res.setHeader(&amp;#39;Content-Disposition&amp;#39;, &amp;#39;attachment; filename=&amp;#39; + encodeURIComponent(filename)); } else if(userAgent.indexOf(&amp;#39;firefox&amp;#39;) &amp;gt;= 0) { res.setHeader(&amp;#39;Content-Disposition&amp;#39;, &amp;#39;attachment; filename*=&amp;#34;utf8\&amp;#39;\&amp;#39;&amp;#39; + encodeURIComponent(filename)+&amp;#39;&amp;#34;&amp;#39;); } else { res.setHeader(&amp;#39;Content-Disposition&amp;#39;, &amp;#39;attachment; filename=&amp;#39; + new Buffer(filename).toString(&amp;#39;binary&amp;#39;)); } // 解决excel打开内容乱码 var dataBuffer = Buffer.concat([new Buffer(&amp;#39;\xEF\xBB\xBF&amp;#39;, &amp;#39;binary&amp;#39;), new Buffer(data)]); res.send(dataBuffer);</description></item><item><title>NodeJs 按行读取文件</title><link>//imziv.com/posts/2014/nodejs-%E6%8C%89%E8%A1%8C%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 02 Sep 2014 15:56:41 +0000</pubDate><guid>//imziv.com/posts/2014/nodejs-%E6%8C%89%E8%A1%8C%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6/</guid><description>次中方法非依赖第三方 package, 当然你可以用。
line-reader 直接上代码：
var fs = require(&amp;#39;fs&amp;#39;), readline = require(&amp;#39;readline&amp;#39;); var rd = readline.createInterface({ input: fs.createReadStream(&amp;#39;./test.txt&amp;#39;), output: process.stdout, terminal: false }); var i = 1; rd.on(&amp;#39;line&amp;#39;, function(line) { console.log(&amp;#39;第&amp;#39;+ i +&amp;#39;行：&amp;#39;+ line); write(line); i++; });</description></item></channel></rss>