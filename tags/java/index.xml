<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 让美的事情发生</title><link>//imziv.com/tags/java/</link><description>Recent content in Java on 让美的事情发生</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2012-2020 Ziv小威</copyright><lastBuildDate>Fri, 25 Apr 2014 14:12:51 +0000</lastBuildDate><atom:link href="//imziv.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>从文件导数据到数据库的性能优化思路（笔记）</title><link>//imziv.com/posts/2014/%E4%BB%8E%E6%96%87%E4%BB%B6%E5%AF%BC%E6%95%B0%E6%8D%AE%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E7%AC%94%E8%AE%B0-/</link><pubDate>Fri, 25 Apr 2014 14:12:51 +0000</pubDate><guid>//imziv.com/posts/2014/%E4%BB%8E%E6%96%87%E4%BB%B6%E5%AF%BC%E6%95%B0%E6%8D%AE%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E7%AC%94%E8%AE%B0-/</guid><description>概述 最近公司一.NET 项目需要对其日志 Log 入数据库统计，写这个脚本导入的任务便落到我身上了。采用了熟练的 Java,这个日志也不是很大，一个文件大概几兆，有上万条数据，一天大概有 7,8 个文件需要这样的导入处理。由于之前写 Web 没有这么去批处理这么多数据，所以没有太注意性能，第一个版本程序导入速度慢的吓人，一个文件导完可能需要 10 多分钟，也就是说如果把每天的文件导完可能需要 2 个多小时的时间，听听就很蛋疼，最终经过优化后，一个文件导入也就几秒，甚至可以更短。目标日志文件的信息都是按行存储，所以程序中按行读取后，然后进行相应的字符串截取入库。下面则为思路分享以及主要代码的分享。
优化思路 1.程序流程： 程序先读取本地的文件到内存，然后把内存的数据批量 Insert 到数据库。 2.归纳：可以看出首先程序需要进行文件 IO 操作，然后则是数据 JDBC 操作，所以优化方向大致可以是以下几个： a.文件 IO 优化 b.JDBC 操作优化 c.使用多线程并行 JDBC 操作
文件常见 IO 简介 Java 的文件读写操作大概有这么几种方式，但是我们应该注意几种文件操作方式的区别，哪些操作方式适合不同的数据文件对象。 1.（InputStream/OutputStream) 为字节输入/输出流，这种读写方式都是按一定字节量读取数据。 2. （FileInputStream/FileOutputStream) 此方法继承自上面的（InputStream/OutpustStream）,同样按字节流输入/输出，用于读取图像之类的原始字节流 3.（FileReader/FileWriter) 此方法适用于按字符流的文件操作 4. （BufferedReader/BufferedWriter) 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。
注：更详细的 IO 操作说明，请查看具体的 JDK 文档。 此处我采用的 BufferedReader 按行读取，效率比较好 代码片段：
public static List&amp;lt;String&amp;gt; getLogLinesByBuf(String filePath){ List&amp;lt;String&amp;gt; items = new ArrayList&amp;lt;String&amp;gt;(); File file = new File(filePath); BufferedReader reader; if (file.</description></item><item><title>fileloder.js+struts2 实现文件异步上传，无页面刷新效果。</title><link>//imziv.com/posts/2012/fileloder.js+struts2%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E6%97%A0%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%88%E6%9E%9C/</link><pubDate>Thu, 01 Nov 2012 11:11:00 +0000</pubDate><guid>//imziv.com/posts/2012/fileloder.js+struts2%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E6%97%A0%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%88%E6%9E%9C/</guid><description>一、前言 　之前在写一个 web 的文件上传的功能时，希望在 web 前端对文件的大小，及类型用 js 给验证掉，然后提交到服务器保存入数据库，同时要求达到页面无刷新的异步效果。在网上也看到有很多用 iframe 的方式实现了这样的无刷新效果。不过我在这里给大家介绍的是一款 js 插件，非常强大。在用这款插件前，在网上查询了好久关于 js 对文件类型的验证，当然这样的方法很多，大多数通过正则表达式对文件后缀验证的方式，只不过对文件大小验证这项功能上网上贴出的大多数代码都不靠谱，很多浏览器根本就不支持很多属性操作，比喻说 filesize 这项，而且浏览器的兼容性上考虑起来非常麻烦。不过所幸后来我找到了 fileloader.js 这个插件，前身好像是 ajaxfileupload.js，这款插件可通过 js 提交验证文件的大小及类型、支持拖拽上传。有时间把它的源码研究下也跟大家分享下。fileloader.js 官方地址是：&amp;laquo;http://fineuploader.com/&amp;gt;。当然上面也有很多 DEMO&amp;gt;，大家可以自己去看。
二、工作准备 　添加 strut2 框架；将下载的 fileloader.js 的文件添加到页面；将 fileloader.css 文件添加到页面；添加 jquery 包。
三、HTML 页面代码 &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;文件上传&amp;lt;/title&amp;gt; &amp;lt;link href=&amp;#34;css/fileuploader.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; /&amp;gt; &amp;lt;script language=&amp;#34;javascript&amp;#34; type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;js/jquery-1.8.0.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script language=&amp;#34;javascript&amp;#34; type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;js/fileuploader.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script language=&amp;#34;javascript&amp;#34; type=&amp;#34;text/javascript&amp;#34;&amp;gt; $(document).ready(function() { var thumbnailuploader = new qq.FileUploader({　//new fileuploader object element: $(&amp;#39;#thumbnail-fine-uploader&amp;#39;)[0],　//选定页面div元素，这里用了jquery的选择器 action: &amp;#39;service/uploadImage&amp;#39;,　//提交的action地址 debug: true, multiple: false, allowedExtensions: [&amp;#39;jpeg&amp;#39;, &amp;#39;jpg&amp;#39;, &amp;#39;gif&amp;#39;, &amp;#39;png&amp;#39;],　//允许上传的文件类型 sizeLimit: 500*1024,　//允许上传文件的大小，这里是500KB，500kb = 500*1024KB uploadButtonText:&amp;#39;图片上传&amp;#39;,　//在页面显示上传按钮 inputName: &amp;#39;myFile&amp;#39;,　//在input标签中的name属性设置为myFile messages:{　//设置的提示信息，包括大小类型等的操作 typeError:&amp;#39;只允许jpeg,jpg,gif,png格式的图片文件{file}&amp;#39;, sizeError:&amp;#39;文件大小不能超过{sizeLimit}。{file}&amp;#39;, emptyError:&amp;#39;文件不可为空{file}&amp;#39;, onLeave:&amp;#39;文件正在上传，离开将终止上传操作？&amp;#39; }, showMessage:function(message){　//显示信息 alert(message); }, // 设置返回从服务器反馈的error信息，不过我这里利用这个responseProperty属性反馈msg信息， // 具体的msg内容在服务中设置。 failedUploadTextDisplay: { mode: &amp;#39;custom&amp;#39;, maxChars: 40, responseProperty: &amp;#39;msg&amp;#39;, enableTooltip: true } }); })　&amp;lt;/scripte&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;fieldset&amp;gt; &amp;lt;legend&amp;gt;&amp;lt;span&amp;gt;您可以上传一张不超过500kb的图片&amp;lt;/span&amp;gt;&amp;lt;/legend&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div id=&amp;#34;thumbnail-fine-uploader&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/fieldset&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 三、Action 服务器端代码 提示：我在项目中使用了 S2SH 框架，所以注意下自己写代码时候的区别。</description></item></channel></rss>